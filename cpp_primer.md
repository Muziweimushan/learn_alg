
# 第9章.顺序容器(sequential container)
> 顺序容器,即为程序员提供控制元素存储和访问顺序能力的容器.此处的顺序不依赖元素的值,而是与元素加入容器时的位置相对应.

## 顺序容器类型

class name      |解释                       |特性
:---            |:---                       |:---
vector          | 可变大小数组              | 支持快速随机访问.在尾部之外的位置插入或删除元素可能很慢
deque           | 双端队列                  | 支持快速随机访问.在头尾位置插入/删除速度很快
list            | 双向链表                  | 只支持双向顺序访问.在list中任何位置进行插入/删除操作速度都很快
forward_list    | 单向链表                  | 只支持单向顺序访问.在链表任何位置进行插入/删除操作速度都很快
array           | 固定大小数组              | 支持快速随机访问.不能添加或删除元素
string          | 专用于保存字符的vector    | 随机访问快.在尾部插入/删除速度快

### 对比
    array是对语言原生数组的拓展
    vector和string将元素保存在连续空间中.存储空间连续使得通过元素下标来计算其地址非常快速.由此它们支持快速随机访问.随之带来的问题是在容器中间位置插入或删除元素会非常耗时
    list和forward_list设计目的是令容器任何位置的添加和删除操作都非常快速.但缺陷是它们不支持元素的随机访问.如果确实需要访问所有元素,则只能通过遍历容器的方式实现.
    deque是一个与vector类似的更高级的容器.在deque的中间插入/删除元素代价(可能)很高.但是,在deque的两端进行添加/删除元素的效率则很快.
    forward_list的设计目的是达到与最好的手写单向链表数据结构相当的性能.为此.forward_list没有size操作(因为保存或计算大小会引入额外开销),其他的容器的size操作则保证是一个常量时间的快速操作.

#### 使用建议
+ 除非有很好理由选择其他容器,否则应使用vector
+ 如果程序有很多小元素,且空间额外开销很重要,则不要使用list或forward_list
+ 如果需要随机访问元素,则使用vector或deque
+ 如果需要在容器中间进行插入/删除操作,则应使用list/forward_list
+ 如果需要在容器头尾进行插入/删除操作,而不会在中间进行,则使用deque

## 9.2.容器库概览

### 9.2.1.迭代器

#### 迭代器的用途
+ 我们可以通过迭代器访问标准容器中的元素
+ 这操作通过解引用运算符(*)来实现的
+ 同时,迭代器提供递增运算符(++)从当前元素移动到下一个元素

#### 标准容器迭代器的运算符

运算符              | 作用
:---                |:---
*iter               | 返回迭代器iter所指元素的引用
iter->mem           | 解引用iter并获取该元素的名为mem的成员,等价于(*iter).mem
++iter              | 令iter指示容器的下一个元素
--iter              | 令iter指示容器的上一个元素(**forward_list不支持**)
iter1 == iter2      | 判断两迭代器是否相等(不相等),如果两个迭代器指示的是同一个元素或者它们是同一个迭代器的尾后迭代器(c.end()),则相等,反之不相等
iter1 != iter2 


#### 迭代器范围
一个迭代器范围由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或是尾元素之后的位置.这两个迭代器通常称为begin和end.
** end迭代器从来不会指向范围中的最后一个元素,而是指向尾元素之后的位置. **
> 迭代器范围中的元素包含begin/first所表示的元素以及从begin/first开始直至last/end(**但不包含last/end**)之间的所有元素. 这其实就是数学描述上的前闭后开区间[begin, end)

+ 如果begin与end相等,则范围相等
+ 如果begin与end不等,则范围至少包含一个元素,且begin指向该范围中的第一个元素
+ 我们可以对begin递增若干次,使得begin==end

```
while (end != begin)
{
    /*通过解引用begin访问范围内的元素*/

    ++begin;    /*移动迭代器,获取下一个元素,注意这里是前置++*/
}

```

### 9.2.4.容器定义和初始化
#### 将一个容器初始化为另一个容器的拷贝
将一个新容器新创建为另一个容器的拷贝有两种方法:
+ 直接拷贝整个容器----要求容器类型以及元素类型都必须匹配
+ 由一对迭代器对指定的元素范围进行拷贝(array不支持这种方式)----容器类型不需要匹配,元素类型之间只要能做转换即可.

#### 列表初始化

```
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector< const char * > articles = {"a", "an", "the"};
```

通过列表初始化我们显式的指定了容器中每个元素的值.同时,对于除了array容器以外的容器类型,初始化列表隐含地指定了容器的大小:容器将包含与初始值一样多的元素

#### 顺序容器大小相关的构造函数
除了array以外,顺序容器还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值.
+ 当元素类型是内置类型或具有默认构造函数的类类型,可以仅提供一个容器大小参数;否则需要显式指定一个元素初始值.
+ 关联容器并不提供这种构造函数

#### 总结,容器(array除外)的4种初始化方式

方式                                            | 举例                      | 说明
:--- | :--- | :---
默认构造函数                                    | C c                       | 如果C是araay类型,则c中元素按默认方式初始化,否则c为空
c1初始化为c2的拷贝                              | C c1 = c2 或 C c1(c2)     | c1和c2必须是相同类型(array的话大小必须相同),相同类型指的是容器类型相同以及元素类型也想同
c初始化为初始化列表中元素的拷贝.                | C c={c1, c2, c3 ...};     | 列表中元素类型必须与容器C的元素类型相同.(对于array类型,列表元素数目必须小于或等于array的大小,遗漏的元素将使用值初始化)
使用迭代器b和e指定范围中元素的拷贝进行初始化    | C c(b, e)                 | 范围中元素的类型必须与C的元素类型相同.array不适用此初始化方式

####此外,顺序容器还有跟大小相关的2种初始化方式

创建元素个数为n,并对元素进行值初始化        | C seq(n)      | seq包含n个元素,这些元素进行值初始化;此构造函数是explicit的.string不适用
:--- | :--- | :---
创建元素个数为n,初始值为t的容器             | C seq(n, t)   | seq包含n个初始化值为t的元素


### 9.2.5.赋值和swap


##9.3.顺序容器操作

### 9.3.2.访问元素


### 9.3.3.删除元素
顺序容器的删除操作包括
方式                        | 示例  | 说明
:--- | :--- | :---


