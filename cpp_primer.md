
# 第9章.顺序容器(sequential container)
> 顺序容器,即为程序员提供控制元素存储和访问顺序能力的容器.此处的顺序不依赖元素的值,而是与元素加入容器时的位置相对应.

## 顺序容器类型

class name      |解释                       |特性
:---            |:---                       |:---
vector          | 可变大小数组              | 支持快速随机访问.在尾部之外的位置插入或删除元素可能很慢
deque           | 双端队列                  | 支持快速随机访问.在头尾位置插入/删除速度很快
list            | 双向链表                  | 只支持双向顺序访问.在list中任何位置进行插入/删除操作速度都很快
forward_list    | 单向链表                  | 只支持单向顺序访问.在链表任何位置进行插入/删除操作速度都很快
array           | 固定大小数组              | 支持快速随机访问.不能添加或删除元素
string          | 专用于保存字符的vector    | 随机访问快.在尾部插入/删除速度快

### 对比
    array是对语言原生数组的拓展
    vector和string将元素保存在连续空间中.存储空间连续使得通过元素下标来计算其地址非常快速.由此它们支持快速随机访问.随之带来的问题是在容器中间位置插入或删除元素会非常耗时
    list和forward_list设计目的是令容器任何位置的添加和删除操作都非常快速.但缺陷是它们不支持元素的随机访问.如果确实需要访问所有元素,则只能通过遍历容器的方式实现.
    deque是一个与vector类似的更高级的容器.在deque的中间插入/删除元素代价(可能)很高.但是,在deque的两端进行添加/删除元素的效率则很快.
    forward_list的设计目的是达到与最好的手写单向链表数据结构相当的性能.为此.forward_list没有size操作(因为保存或计算大小会引入额外开销),其他的容器的size操作则保证是一个常量时间的快速操作.

#### 使用建议
+ 除非有很好理由选择其他容器,否则应使用vector
+ 如果程序有很多小元素,且空间额外开销很重要,则不要使用list或forward_list
+ 如果需要随机访问元素,则使用vector或deque
+ 如果需要在容器中间进行插入/删除操作,则应使用list/forward_list
+ 如果需要在容器头尾进行插入/删除操作,而不会在中间进行,则使用deque

## 9.2.容器库概览

### 9.2.1.迭代器

#### 迭代器的用途
+ 我们可以通过迭代器访问标准容器中的元素
+ 这操作通过解引用运算符(*)来实现的
+ 同时,迭代器提供递增运算符(++)从当前元素移动到下一个元素

#### 标准容器迭代器的运算符

运算符              | 作用
:---                |:---
*iter               | 返回迭代器iter所指元素的引用
iter->mem           | 解引用iter并获取该元素的名为mem的成员,等价于(*iter).mem
++iter              | 令iter指示容器的下一个元素
--iter              | 令iter指示容器的上一个元素(**forward_list不支持**)
iter1 == iter2      | 判断两迭代器是否相等(不相等),如果两个迭代器指示的是同一个元素或者它们是同一个迭代器的尾后迭代器(c.end()),则相等,反之不相等
iter1 != iter2 



