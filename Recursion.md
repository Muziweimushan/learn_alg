# chapter1.递归

## lesson1.重拾递归
### 什么是递归?
    递归是一种数学上分而自治的思想(问题分解)
        分解后的问题与原问题的类型完全相同,但问题复杂度降低(递归中非常重要的特征,问题规模不断变小,但类型完全一致)
        通过相对简单问题(子问题)的解,能轻易求得原问题的解

        递归与递推的思想相同,但表现形式不同
            递归强调"归",即:求解子问题后"回到原处"解决当前问题(出去带着子问题的答案回来解决原答案)
            递推强调"逐渐接近",即:在既定策略下一步一步求解问题

    递归与递推的本质差异
        递归在求解原问题时:
            可能将原问题分解为多个子问题,并等待所有子问题求解结束
            得到所有子问题答案后,需要对子问题答案进行汇总,平衡,取舍...

        递推在求解原问题时:
            假设在既定策略下,能够逐步接近问题答案
            递推中的策略保证每一个求解步骤总是能接近问题答案

### 递归的一般表示法

### 递归在程序设计中的应用----递归函数
    函数体中存在自我调用的函数即递归函数
    递归函数必须有递归出口(边界条件)
    函数的无限递归将导致程序崩溃(函数调用栈越界)

#### 示例1
    问题: 已知二叉树bt结点中保存的是整型值,给定具体数值x.判断是否存在从根节点到叶节点的一条路径,该路径上结点数值之和等于x.若该路径存在,打印该路径:

    思路:
    **二叉树是递归定义的,优先考虑递归解法**
    考虑简单情况:当二叉树只有根节点时,直接比较
    当二叉树存在多个节点:
        在左子树中查找是否存在和为(x-v)的路径
        在右子树中查找是否存在和为(x-v)的路径, 其中v为根节点存放的数值

#### 示例2
    问题: 判断字符串s是不是给定二叉树的后续遍历字符串

    思路:
    方案1: 生成后续遍历字符串,然后进行字符串比较----重点在后序遍历字符串如何生成,数据结构中树提供此接口
    方案2: 后续遍历的同时,与目标字符串进行比较----如何确定待比较字符在目标字符串中的位置


## lesson2.再论递归函数设计
### 递归函数设计要点
+ 先考虑递归出口(最简单的情况)
** 要点: 可直接得到答案(终止递归的地方) **

+ 将原问题分解(递归如何抵达递归出口就依赖于问题的分解)
** 要点: 子问题与原问题类型相同,规模较小.即: 用相同方法可求解子问题 **

### 设计递归函数时,如何更好的分解原问题(如果子问题分解的好,递归效率就会更高)

#### 递归的优势
+ 更加直观的定义问题和解决问题
+ 相对非递归算法所需实现的代码量较小

#### 递归的缺陷
+ 需要函数调用栈的支撑
+ 当问题规模较大时(或设计不当)将造成栈溢出而导致程序崩溃

#### 解决方案一: 二分子问题


#lesson 3.递归到循环的转换
## 递归问题的非递归解法
+ 使用递推思想转换递归问题(确定目标,制定策略,选择起点决)
+ 将递归思想用非递归方式表达
> 核心:抓住递归的本质,使用栈数据结构模拟递归调用
    + 入栈操作:尝试解决问题
    + 出栈操作:得到问题答案




